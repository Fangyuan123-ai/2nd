Products of various types are displayed in a row in a home appliance store. However, the positions of sold products have been filled with no planning, so products of the same type have not been placed together. Employee Na Dae-chung intends to remove all the products of the same type and display products of the same type in a row as long as possible.

1 2 3 4 5 6

[Requirement]

At first, employee Na Dae-chung collected and displayed the products of the same type in a row. However, when a new product has been placed in the position of a sold product, the position has been filed with a product randomly, so that now products of different types are mixed up. Employee Na Dae-chung wishes to collect and place products of the same type together again, but it is practically impossible. So, he wishes to remove all the products of one type and place products of the same type in a row.

7 8 9 10 11 12 13 14 15 16 17 18 19

If there are a number of ways to display the products of the same type in the longest line, he plans to remove all of the products of the type with the highest number from among them.

Exe

For example, if 10 products of types 2, 3, and 7 are displayed as shown below, there are three ways to remove those same types.

Quiz Info

23

3

7272

7

3

3

When type 2 is removed, 3 products of type 7 are displayed in a row.

23

37

2

7

2

7

3

3

When type 3 is removed, there is no product of the same type displayed in a row as shown below. In other words, there is only one product of the same type.

2

3

37

2

7

2

7

3

3

When type 7 is removed, 2 products of both types 2 and 3 are displayed in a row.

23 3

7 2

7

2

7 3

3

When type 2 is removed, 3 products of type 7 are displayed in a row, so this is the best method.

Employee Na Dae-chung intends to find the best method by simulating all possible cases using the above method. Calculating it by hand takes a long time, so he intends to solve it using a program.


The code given below is a C code that finds the largest number of products displayed in a row. For other languages, refer to the given template.

Employee Na Dae-chung, when ID of a type is inputted as a parameter, intends to modify the code to find the maximum number of products displayed in a row when all the products of the relevant ID are removed. He added a parameter, but he is contemplating how to modify the source.

int CalLargestBlock(int id_ignore) {

int max_block_size = 0;

int cur_size = 1;

for (int i = 1; i < N; i++) {

if (ID[i] == ID [i - 1]) cur_size++;

else cur_size = 1;

if (max_block_size < cur_size) {

}

max_block_size = cur_size;

}

return max_block_size;

}


Solve Employee Na Dae-chung's concerns by modifying the given code so that the desired result can be obtained.

[Input format]

In the first line, the number of products N is inputted. (N is an integer, 10 ≤ N≤1,000) In the second line, N product types (ID) are inputted. (ID is an integer, 0 ≤ ID ≤ 1,000,000)

[Output format]

When the products of a particular type are removed, No. of the product of the same type that is displayed in the maximum length line is outputted.

Input/Output Example

: Blank

: Line Break

Tab

Example 1

Input

104

2.3.3.7.27_2_7_33

Output

24

Π

• Please keep the input and output formats carefully

import java.io.*;

import java.util.*;

public class Main {

int N;

int ID[]:

int CalLargestBlock(int id_ignore) {

int max_block_size = 0;

int cur_size = 1;

for (int i=1; i < N; i++) {

if (ID[i]== ID [1-1]) cur_size++;

else cur_size = 1;

if (max_block_size < cur_size) {

max_block_size = cur_size;

}

}

return-max_block_size;
}
int Solve(){

int sol (int) 1e7, max_cnt = 0;

for (int 10; 1 < N; 1++) {

int ret CalLargestBlock(ID[1]);

if ((max_cnt < ret) || ((max_cnt == ret) && (sol < ID[1]))) {

max_cnt ret;

sol ID[1];

}

}

return sol;

}

void InputData() throws IOException {

BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)

N = Integer.parseInt(bf.readLine());

ID= new int[N];

String in[] = bf.readLine().split(".");

for (int i=0; i < N; i++) {

ID[i] = Integer.parseInt(in[i]);

}

bf.close();

}

void OutputData(int ans) throws IOException {

BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.ou

bw.write(String.valueOf(ans) + "\n");

bw.flush();

bw.close();

} public static void main(String[] args) throws IOException {

Main = new Main();

// 입력받는 부분

m.InputData();

int ans = m.Solve();

// 출력하는 부분

m.OutputData(ans);

}
Only modify CalLargestBlock


int CalLargestBlock(int id_ignore) {
    int max_block_size = 0; // Maximum block size found
    int left = 0;          // Left pointer of the sliding window

    for (int right = 0; right < N; right++) {
        // If the product type is the one to ignore, move the left pointer
        if (ID[right] == id_ignore) {
            left = right + 1;
        } else {
            // Update the maximum block size
            max_block_size = Math.max(max_block_size, right - left + 1);
        }
    }

    return max_block_size;
}
